diff -aur distcc-3.1.orig/src/compile.c distcc-3.1/src/compile.c
--- distcc-3.1.orig/src/compile.c	2010-07-04 12:13:04.000000000 +0300
+++ distcc-3.1/src/compile.c	2010-07-06 02:49:24.446657228 +0300
@@ -527,6 +527,9 @@
     /* Lock ordering invariant: always acquire the lock for the
      * remote host (if any) first. */
 
+    dcc_note_state_slot(-1);
+    /* my_state.slot = -1; */
+
     /* Choose the distcc server host (which could be either a remote
      * host or localhost) and acquire the lock for it.  */
     if ((ret = dcc_pick_host_from_list_and_lock_it(&host, &cpu_lock_fd)) != 0) {
diff -aur distcc-3.1.orig/src/state.c distcc-3.1/src/state.c
--- distcc-3.1.orig/src/state.c	2010-07-04 12:13:04.000000000 +0300
+++ distcc-3.1/src/state.c	2010-07-06 02:47:49.871658348 +0300
@@ -253,5 +253,14 @@
 
 void dcc_note_state_slot(int slot)
 {
-    my_state.slot = slot;
+    /* Only set slot the first time. The next call to this function
+     * actually locks a local slot, not a remote one. See the call graph
+     * in dcc_build_somewhere: the first lock is acquired by 
+     * dcc_pick_host_from_list_and_lock_it. Next dcc_lock_local_cpp acquires
+     * a local lock. Without this test, the remote slot number gets overwritten.
+     * The same function actually writes the state.
+     * Furthermore, the slot is not actually used anywhere but by the
+     * monitoring API in mon.c and the standard clients. */
+    if (my_state.slot < 0 || slot < 0)
+        my_state.slot = slot;
 }

